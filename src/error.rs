use std::fmt::{self, Display};
use std::path::{Path, PathBuf};
use std::ops::Deref;
use std::cmp::PartialEq;
use std::io;
use std::ffi::{OsStr, OsString};

use failure::{Fail, Backtrace, Context};
//circular dependency (error <-> rte) but ok here
use ::spec::TemplateSpec;

#[derive(Debug)]
pub struct InsertionError<E: Fail> {
    pub error: E,
    pub failed_new_value: TemplateSpec,
    pub old_value: Option<TemplateSpec>
}

impl<E> Fail for InsertionError<E>
    where E: Fail
{
    fn backtrace(&self) -> Option<&Backtrace> {
        self.error.backtrace()
    }

    fn cause(&self) -> Option<&Fail> {
        self.error.cause()
    }
}

impl<E> Display for InsertionError<E>
    where E: Fail
{
    fn fmt(&self, fter: &mut fmt::Formatter) -> fmt::Result {
        Display::fmt(&self.error, fter)
    }
}



#[derive(Debug)]
pub struct CreatingSpecError {
    inner: Context<CreatingSpecErrorVariant>
}

impl CreatingSpecError {

    pub fn variant(&self) -> &CreatingSpecErrorVariant {
        self.inner.get_context()
    }
}
impl Fail for CreatingSpecError {
    fn backtrace(&self) -> Option<&Backtrace> {
        self.inner.backtrace()
    }

    fn cause(&self) -> Option<&Fail> {
        self.inner.cause()
    }
}

impl Display for CreatingSpecError {
    fn fmt(&self, fter: &mut fmt::Formatter) -> fmt::Result {
        Display::fmt(&self.inner, fter)
    }
}

impl From<CreatingSpecErrorVariant>for CreatingSpecError {
    fn from(variant: CreatingSpecErrorVariant) -> Self {
        CreatingSpecError::from(Context::new(variant))
    }
}

impl From<Context<CreatingSpecErrorVariant>> for CreatingSpecError {
    fn from(inner: Context<CreatingSpecErrorVariant>) -> Self {
        CreatingSpecError { inner }
    }
}

impl From<io::Error> for CreatingSpecError {
    fn from(io_err: io::Error) -> Self {
        io_err.context(CreatingSpecErrorVariant::IoError).into()
    }
}



#[derive(Debug, Fail)]
pub enum CreatingSpecErrorVariant {

    #[fail(display = "path must also be valid string, got: {}", _0)]
    NonStringPath(DisplayPath),

    #[fail(display =  "no type info in settings for: {:?}", type_name)]
    MissingTypeInfo { type_name: String },

    #[fail(display = "media type creation for body failed")]
    BodyMediaTypeCreationFailure,

    #[fail(display = "media type creation for Embedding/Attachment failed")]
    ResourceMediaTypeCreationFailure,

    #[fail(display = "multiple embeddings with the in-template name {:?} where found", name)]
    DuplicateEmbeddingName { name: String },

    #[fail(display = "template dir has to contain at last one sub-template. dir: {}", dir)]
    NoSubTemplatesFound { dir: DisplayPath },

    #[fail(display = "sub-template folder does not contain a template file: {}", dir)]
    TemplateFileMissing { dir: DisplayPath },

    #[fail(display = "sub-template folder does contain more than one template file: {}", dir)]
    MultipleTemplateFiles { dir: DisplayPath },

    #[fail(display = "I/O Error occurred when loading the spec")]
    IoError,

    #[fail(display = "the template/embedding/attachment <{}> is not a file", _0)]
    NotAFile(DisplayPath),

    #[fail(display = "given file does not have a valid (i.e. us-ascii/utf8) file stem: {}", _0)]
    NoValidFileStem { file: DisplayPath },

    #[fail(display = "no media type is registered for the file stem {:?}", stem)]
    NoMediaTypeFor { stem: String },

    #[fail(display = "stem and content type differ: {:?} != {:?} wrt. {}",
        by_extension, by_content, path)]
    FileStemAndContentDifferInMediaType {
        path: DisplayPath,
        by_extension: String,
        by_content: String
    },

    #[fail(display = "media type is not valid utf-8")]
    NonUtf8MediaType,

    #[fail(display = "the media type generated by a media type sniffer is invalid")]
    NotAMediaType,

    #[fail(display = "constructing a IRI with the scheme {} and the path {} failed", scheme, tail)]
    IRIConstructionFailed {
        scheme: &'static str,
        tail: DisplayPath
    }
}


#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct DisplayPath(pub PathBuf);

impl DisplayPath {
    pub fn as_path(&self) -> &Path {
        self.0.as_path()
    }
}

impl Display for DisplayPath {
    fn fmt(&self, fter: &mut fmt::Formatter) -> fmt::Result {
        Display::fmt(&self.0.display(), fter)
    }
}

impl<'a> From<&'a OsStr> for DisplayPath {
    fn from(path: &'a OsStr) -> Self {
        DisplayPath(Path::new(path).to_owned())
    }
}

impl<'a> From<&'a Path> for DisplayPath {
    fn from(path: &'a Path) -> Self {
        DisplayPath(PathBuf::from(path))
    }
}

impl From<PathBuf> for DisplayPath {
    fn from(path: PathBuf) -> Self {
        DisplayPath(path)
    }
}

impl From<OsString> for DisplayPath {
    fn from(path: OsString) -> Self {
        DisplayPath(path.into())
    }
}

impl From<DisplayPath> for PathBuf {
    fn from(dp: DisplayPath) -> Self {
        dp.0
    }
}

impl AsRef<Path> for DisplayPath {
    fn as_ref(&self) -> &Path {
        self
    }
}

impl Deref for DisplayPath {
    type Target = Path;

    fn deref(&self) -> &Self::Target {
        self.as_path()
    }
}

impl PartialEq<Path> for DisplayPath {

    fn eq(&self, other: &Path) -> bool {
        self.as_path() == other
    }
}

impl<'a> PartialEq<&'a Path> for DisplayPath {
    fn eq(&self, other: &&'a Path) -> bool {
        self == *other
    }
}

impl PartialEq<PathBuf> for DisplayPath {

    fn eq(&self, other: &PathBuf) -> bool {
        self.as_path() == other
    }
}